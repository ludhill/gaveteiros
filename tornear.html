<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Torno CNC</title>
    <style>
        body { font-family: system-ui, sans-serif; background-color: #f0f2f5; margin: 0; padding: 20px; }
        h1, h3 { text-align: center; color: #333; }
        .container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
        .controls { flex: 1; min-width: 350px; max-width: 450px; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .viewers { flex: 2; display: flex; flex-wrap: wrap; gap: 20px; min-width: 500px; }
        .viewer-box { flex: 1; min-width: 400px; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        label { display: block; margin-top: 10px; font-weight: bold; }
        input[type="number"] { width: calc(100% - 10px); padding: 5px; margin-top: 5px; }
        textarea { width: 100%; height: 250px; margin-top: 5px; font-family: 'Courier New', monospace; box-sizing: border-box; }
        button { width: 100%; padding: 12px; margin-top: 15px; border: none; border-radius: 5px; background-color: #d9534f; color: white; font-size: 1.1em; cursor: pointer; }
        canvas { display: block; background-color: #fdfdfd; border: 1px solid #ccc; }
    </style>
</head>
<body>

    <h1>Simulador de Usinagem de Torno CNC</h1>

    <div class="container">
        <div class="controls">
            <h3>1. Parâmetros da Peça</h3>
            <label for="cilindro-diametro">Diâmetro do Cilindro (mm):</label>
            <input type="number" id="cilindro-diametro" value="50">
            <label for="cilindro-comprimento">Comprimento do Cilindro (mm):</label>
            <input type="number" id="cilindro-comprimento" value="100">

            <h3>2. Código G</h3>
            <textarea id="gcode-input" placeholder="Insira o G-code para o perfil (eixos X e Z)..."></textarea>
            
            <button id="simular-button">Simular Usinagem</button>
        </div>

        <div class="viewers">
            <div class="viewer-box">
                <h3>Perfil 2D (Vista Lateral)</h3>
                <canvas id="canvas-2d" width="400" height="300"></canvas>
            </div>
            <div class="viewer-box">
                <h3>Peça Final 3D</h3>
                <canvas id="canvas-3d" width="400" height="300"></canvas>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- CONFIGURAÇÃO 3D ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee);
        const canvas3d = document.getElementById('canvas-3d');
        const camera = new THREE.PerspectiveCamera(50, canvas3d.width / canvas3d.height, 0.1, 1000);
        camera.position.set(100, 100, 150);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas3d, antialias: true });
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);
        let pecaMesh;

        // --- CONFIGURAÇÃO 2D ---
        const canvas2d = document.getElementById('canvas-2d');
        const ctx2d = canvas2d.getContext('2d');

        // --- LÓGICA PRINCIPAL ---
        document.getElementById('simular-button').addEventListener('click', simularUsinagem);

        function simularUsinagem() {
            // 1. Obter parâmetros da UI
            const diametro = parseFloat(document.getElementById('cilindro-diametro').value);
            const comprimento = parseFloat(document.getElementById('cilindro-comprimento').value);
            const gcode = document.getElementById('gcode-input').value;

            const raio = diametro / 2;

            // 2. Gerar o perfil inicial do cilindro (um retângulo)
            // Pontos para a geometria de revolução do Three.js
            const perfilInicialPoints = [
                new THREE.Vector2(0, 0),
                new THREE.Vector2(raio, 0),
                new THREE.Vector2(raio, comprimento),
                new THREE.Vector2(0, comprimento)
            ];

            // 3. Processar o G-code para obter o perfil final
            const perfilFinalPoints = processarGCode(gcode, raio, comprimento);
            
            // 4. Desenhar os perfis 2D
            desenharPerfil2D(perfilInicialPoints, perfilFinalPoints);
            
            // 5. Gerar e exibir a peça 3D
            gerarPeca3D(perfilFinalPoints);
        }
        
        function processarGCode(gcode, raioMax, comprimentoMax) {
            const lines = gcode.split('\n');
            // O perfil começa no ponto inicial (centro da face) e vai para a borda
            let perfil = [new THREE.Vector2(0, 0), new THREE.Vector2(raioMax, 0)]; 
            let pos = { x: raioMax, z: 0 }; // Posição da ferramenta (X é raio, Z é comprimento)

            for (const line of lines) {
                const trimmedLine = line.trim().toUpperCase().split(';')[0];
                if (!trimmedLine) continue;

                let cmd = trimmedLine.split(' ')[0];
                if (cmd !== 'G1' && cmd !== 'G2' && cmd !== 'G3') continue;

                let newPos = { ...pos };
                let raioArco = null;

                const parts = trimmedLine.match(/[A-Z][-\d\.]+/g) || [];
                parts.forEach(part => {
                    const letter = part.charAt(0);
                    const value = parseFloat(part.substring(1));
                    if (letter === 'X') newPos.x = value / 2; // G-code usa diâmetro, aqui usamos raio
                    if (letter === 'Z') newPos.z = Math.abs(value); // Z é geralmente negativo, usamos positivo
                    if (letter === 'R') raioArco = value;
                });

                if (cmd === 'G1') {
                    perfil.push(new THREE.Vector2(newPos.x, newPos.z));
                } else if ((cmd === 'G2' || cmd === 'G3') && raioArco !== null) {
                    // Simplificação para gerar pontos de arco (uma simulação mais precisa requer trigonometria complexa)
                    // Esta lógica interpola pontos ao longo do arco
                    const startPoint = new THREE.Vector2(pos.x, pos.z);
                    const endPoint = new THREE.Vector2(newPos.x, newPos.z);
                    const arcCurve = new THREE.ArcCurve(0, 0, raioArco, 0, Math.PI, cmd === 'G3'); // Placeholder - a lógica real é mais complexa
                    
                    // Lógica simplificada: adiciona um ponto no meio do caminho para simular a curva
                    let midX = (startPoint.x + endPoint.x) / 2;
                    let midZ = (startPoint.y + endPoint.y) / 2;
                    let dist = startPoint.distanceTo(endPoint) / 2;
                    // Calcula um ponto fora da linha reta para simular a curvatura
                    let normal = new THREE.Vector2(endPoint.y - startPoint.y, -(endPoint.x - startPoint.x)).normalize();
                    let alturaArco = Math.sqrt(Math.max(0, raioArco*raioArco - dist*dist));
                    midX += normal.x * alturaArco * (cmd === 'G3' ? 1 : -1);
                    midZ += normal.y * alturaArco * (cmd === 'G3' ? 1 : -1);

                    perfil.push(new THREE.Vector2(midX, midZ));
                    perfil.push(endPoint);
                }
                
                pos = { ...newPos };
            }

            // Fecha o perfil
            perfil.push(new THREE.Vector2(pos.x, comprimentoMax));
            perfil.push(new THREE.Vector2(0, comprimentoMax));

            return perfil;
        }

        function desenharPerfil2D(inicial, final) {
            ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);
            ctx2d.save();
            
            // Acha a escala para caber no canvas
            const maxDim = Math.max(
                ...inicial.map(p => p.x), 
                ...inicial.map(p => p.y),
                ...final.map(p => p.x),
                ...final.map(p => p.y)
            );
            const scale = Math.min(canvas2d.width / maxDim, canvas2d.height / maxDim) * 0.9;
            
            // Inverte Y e centraliza
            ctx2d.translate(10, canvas2d.height / 2);
            ctx2d.scale(scale, -scale);

            // Desenha perfil inicial
            ctx2d.beginPath();
            ctx2d.moveTo(inicial[0].x, inicial[0].y);
            inicial.forEach(p => ctx2d.lineTo(p.x, p.y));
            ctx2d.closePath();
            ctx2d.strokeStyle = '#cccccc';
            ctx2d.lineWidth = 1 / scale;
            ctx2d.stroke();

            // Desenha perfil final
            ctx2d.beginPath();
            ctx2d.moveTo(final[0].x, final[0].y);
            final.forEach(p => ctx2d.lineTo(p.x, p.y));
            ctx2d.closePath();
            ctx2d.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx2d.fill();
            ctx2d.strokeStyle = '#333333';
            ctx2d.lineWidth = 2 / scale;
            ctx2d.stroke();
            
            // Ponto inicial
            ctx2d.beginPath();
            ctx2d.arc(0, 0, 2 / scale, 0, 2 * Math.PI);
            ctx2d.fillStyle = 'red';
            ctx2d.fill();

            ctx2d.restore();
        }

        function gerarPeca3D(perfil) {
            if (pecaMesh) {
                scene.remove(pecaMesh);
                pecaMesh.geometry.dispose();
                pecaMesh.material.dispose();
            }

            // O perfil deve estar em X e Y para o LatheGeometry
            const points = perfil.map(p => new THREE.Vector2(p.x, p.y));

            const geometry = new THREE.LatheGeometry(points, 32);
            const material = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.3 });
            pecaMesh = new THREE.Mesh(geometry, material);
            pecaMesh.rotation.x = -Math.PI / 2; // Orienta a peça corretamente
            
            scene.add(pecaMesh);

            // Centraliza a câmera
            const box = new THREE.Box3().setFromObject(pecaMesh);
            const center = box.getCenter(new THREE.Vector3());
            controls.target.copy(center);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Inicia com um exemplo
        document.getElementById('gcode-input').value = 'G1 Z-20 X40\nG1 Z-40\nG2 Z-60 X20 R10\nG1 Z-80';
        simularUsinagem();
        animate();
    </script>
</body>
</html>
